## OS Project
## Producer-Consumer 
### 1.원천코드 (producer-consumer.c)를 이용해 컴파일
```C
gcc producer-consumer.c -lpthread
```
* 아무 옵션을 주지 않고 컴파일하니 동기화 함수들이 인식이 되지 않아서 -lpthread옵션을 주고 컴파일하였다.

### 2.실행 파일 실행

* 코드 실행
```C
./a.out
```

#### 실행 결과(출력)
* 서버 프로그램을 실행하면 mkfifo를 통해 fifo를 생성하고, client에서 server로 흐르는 fifo, server에서 client로 흐르는 fifo2개가 만들어지고 서버에서 client2server를 열고 클라이언트에서 client2server를 엶으로써 연결이 된다. server2client fifo도 마찬가지로 연결이 된다.
* server on.이 출력이되고 현재 프로세스의 번호를 보여준다.
* 클라이언트에서 입력받은 하나의 스트링을 " " 토큰으로 잘라서 파일이름, 요청 목적, read면 읽을 바이트 수, write면 입력할 스트링을 구조체에 저장한다.
* 클라이언트에게서 exit를 입력받게되면 서버를 종료한다.
* 서버에서 요청에 따라 응답하는 내용은 다음과 같다.
  * 요청받은 byte수 만큼 읽기(파일의 내용이 byte수 보다 작으면 전부 읽는다.)
  * write시 파일에 쓴 바이트 수를 응답
  * 만약 파일을 여는 도중에 오류가 발생시, 오류가 났음을 알리는 응답
  * 서버 종료 요청(exit)시 서버 종료 확인 응답
  
  
  
## Reader-Writer
### 1. 원천코드(reader-writer.c)를 이용해 컴파일
```C
gcc reader-writer.c -lpthread
```
* producer-consumer 컴파일 할때와 마찬가지로 -lpthread옵션을 이용해 컴파일하였다.

### 2.실행 파일 실행

* 코드 실행
```
./a.out
```

#### 실행 결과(출력)
* 클라이언트 프로그램을 실행하면 server과 fifo를 연결하고 연결이 실패하면 오류 메세지를 출력하고 프로그램을 종료한다.
* 클라이언트 프로그램을 이용하여 서버에게 보내는 요청은 다음과 같다.
  * 파일이름(exit)
  * 파일요청타입(r/w)
  * 타입이 r일 경우 읽을 바이트수|타입이 w일 경우 파일에 입력할 스트링
* 요청후 서버에서 받아와서 출력하는 결과는 다음과 같다
  * 읽은 파일 내용
  * 파일에 쓴 스트링의 바이트 수
  * read혹은 write오류메세지
  * 서버 종료 확인 메세지
  
#### 예시 입력(쓰기)
```C
txt.txt
w
abcdef
```
#### 예시 출력(쓰기)
```C
Written byte: 6
```

#### 예시 입력(읽기)
```C
txt.txt
r
6
```
#### 예시 출력(쓰기)
```C
Read:abcdef
```
#### 예시 입력(종료)
```C
exit
```
